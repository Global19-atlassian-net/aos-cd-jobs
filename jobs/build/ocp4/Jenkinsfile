#!/usr/bin/env groovy


def get_mirror_url(build_mode, version) {
    if (build_mode == "online:int") {
        return "https://mirror.openshift.com/enterprise/online-int"
    }
    return "https://mirror.openshift.com/enterprise/enterprise-${version}"
}

def mail_success(version, mirrorURL, record_log, commonlib) {

    def target = "(Release Candidate)"

    if (BUILD_MODE == "online:int") {
        target = "(Integration Testing)"
    }

    def inject_notes = ""
    if (params.SPECIAL_NOTES.trim() != "") {
        inject_notes = "\n***Special notes associated with this build****\n${params.SPECIAL_NOTES.trim()}\n***********************************************\n"
    }

    def timing_report = get_build_timing_report(record_log)
    def image_list = get_image_build_report(record_log)
    currentBuild.description = timing_report
    currentBuild.result = "SUCCESS"
    PARTIAL = " "
    mail_list = params.MAIL_LIST_SUCCESS
    exclude_subject = ""
    if (BUILD_EXCLUSIONS != "" || BUILD_FAILURES != null) {
        PARTIAL = " PARTIAL "
        currentBuild.displayName += " (partial)"
        if (BUILD_FAILURES != null) {
            mail_list = params.MAIL_LIST_FAILURE
            exclude_subject += " [failed images: ${BUILD_FAILURES}]"
        }
        if (BUILD_EXCLUSIONS != "") {
            exclude_subject += " [excluded images: ${BUILD_EXCLUSIONS}]"
        }
    }

    image_details = """${timing_report}
Images:
  - Images have been pushed to registry.reg-aws.openshift.com:443     (Get pull access [1])
    [1] https://github.com/openshift/ops-sop/blob/master/services/opsregistry.asciidoc#using-the-registry-manually-using-rh-sso-user
${image_list}
"""


    if (!params.BUILD_CONTAINER_IMAGES) {
        PARTIAL = " RPM ONLY "
        image_details = ""
        // Just inform key folks about RPM only build; this is just prepping for an advisory.
        mail_list = params.MAIL_LIST_FAILURE
    }

    commonlib.email(
        to: "${mail_list}",
        from: "aos-cicd@redhat.com",
        subject: "[aos-cicd] New${PARTIAL}build for OpenShift ${target}: ${version}${exclude_subject}",
        body: """\
OpenShift Version: v${version}
${inject_notes}
RPMs:
    Puddle (internal): http://download-node-02.eng.bos.redhat.com/rcm-guest/puddles/RHAOS/AtomicOpenShift/${params.BUILD_VERSION}/${OCP_PUDDLE}
    Exernal Mirror: ${mirrorURL}/${OCP_PUDDLE}
${image_details}

Brew:
  - Openshift: ${OSE_BREW_URL}

Jenkins job: ${env.BUILD_URL}

Are your Atomic OpenShift changes in this build? Check here:
https://github.com/openshift/ose/commits/v${NEW_VERSION}-${NEW_RELEASE}/

""");

    try {
        if (BUILD_EXCLUSIONS == "" && params.BUILD_CONTAINER_IMAGES) {
            timeout(3) {
                sendCIMessage(
                    messageContent: "New build for OpenShift ${target}: ${version}",
                    messageProperties:
                        """build_mode=${BUILD_MODE}
                        puddle_url=${mirrorURL}/${OCP_PUDDLE}
                        image_registry_root=registry.reg-aws.openshift.com:443
                        brew_task_url_openshift=${OSE_BREW_URL}
                        product=OpenShift Container Platform
                        """,
                    messageType: 'ProductBuildDone',
                    overrides: [topic: 'VirtualTopic.qe.ci.jenkins'],
                    providerName: 'Red Hat UMB'
                )
            }
        }
    } catch (mex) {
        echo "Error while sending CI message: ${mex}"
    }
}

// extract timing information from the record_log and write a report string
// the timing record log entry has this form:
// image_build_metrics|elapsed_total_minutes={d}|task_count={d}|elapsed_wait_minutes={d}|
def get_build_timing_report(record_log) {
    metrics = record_log['image_build_metrics']

    if (metrics == null || metrics.size() == 0) {
        return ""
    }

    return """
Images built: ${metrics[0]['task_count']}
Elapsed image build time: ${metrics[0]['elapsed_total_minutes']} minutes
Time spent waiting for OSBS capacity: ${metrics[0]['elapsed_wait_minutes']} minutes
"""
}

// get the list of images built
def get_image_build_report(record_log) {
    builds = record_log['build']

    if ( builds == null ) {
        return ""
    }

    Set image_set = []
    for (i = 0; i < builds.size(); i++) {
        bld = builds[i]
        if (bld['status'] == "0" && bld['push_status'] == "0") {
            image_spec_string =
                "${bld['image']}:${bld['version']}-${bld['release']}"
            image_set << image_spec_string
        }
    }

    return "\nImages included in build:\n    " +
        image_set.toSorted().join("\n    ")
}

// Search the RPM build logs for the named package
// extract the path to the spec file and return that.
def get_rpm_specfile_path(record_log, package_name) {
    rpms = record_log['build_rpm']
    if (rpms == null) {
        return null
    }

    // find the named package and the spec file path
    specfile_path = ""
    for (i = 0 ; i < rpms.size(); i++) {
        if (rpms[i]['distgit_key'] == package_name) {
            specfile_path = rpms[i]['specfile']
            break
        }
    }

    return specfile_path
}

node {
    checkout scm
    def buildlib = load("pipeline-scripts/buildlib.groovy")
    def commonlib = buildlib.commonlib

    // Expose properties for a parameterized build
    properties(
        [
            buildDiscarder(
                logRotator(
                    artifactDaysToKeepStr: '',
                    artifactNumToKeepStr: '',
                    daysToKeepStr: '',
                    numToKeepStr: '1000')),
            [
                $class: 'ParametersDefinitionProperty',
                parameterDefinitions: [
                    commonlib.ocpVersionParam('BUILD_VERSION', '4'),
                    [
                        name: 'BUILD_CONTAINER_IMAGES',
                        description: 'Build container images? Otherwise just RPMs',
                        $class: 'hudson.model.BooleanParameterDefinition',
                        defaultValue: true
                    ],
                    [
                        name: 'BUILD_EXCLUSIONS',
                        description: 'Exclude these images from builds. Comma or space separated list. (i.e cri-o-docker,aos3-installation-docker)',
                        $class: 'hudson.model.StringParameterDefinition',
                        defaultValue: ""
                    ],
                    commonlib.mockParam(),
                    [
                        name: 'TEST',
                        description: 'Run as much code as possible without pushing / building?',
                        $class: 'hudson.model.BooleanParameterDefinition',
                        defaultValue: false
                    ],
                    [
                        name: 'BUILD_MODE',
                        description: '''
Determines where the compose is mirrored:
    pre-release               origin/release-X.Y ->  https://mirror.openshift.com/enterprise/enterprise-X.Y/
    online:int                origin/master -> online-int yum repo
    ''',
                        $class: 'hudson.model.ChoiceParameterDefinition',
                        choices: [
                            "pre-release",
                            "online:int"
                        ].join("\n"),
                        defaultValue: "pre-release"
                    ],
                    commonlib.suppressEmailParam(),
                    [
                        name: 'MAIL_LIST_SUCCESS',
                        description: 'Success Mailing List',
                        $class: 'hudson.model.StringParameterDefinition',
                        defaultValue: [
                            'aos-cicd@redhat.com',
                            'aos-qe@redhat.com',
                            'aos-team-art@redhat.com',
                        ].join(',')
                    ],
                    [
                        name: 'MAIL_LIST_FAILURE',
                        description: 'Failure Mailing List',
                        $class: 'hudson.model.StringParameterDefinition',
                        defaultValue: [
                            'aos-team-art@redhat.com'
                        ].join(',')
                    ],
                    [
                        name: 'SPECIAL_NOTES',
                        description: 'Include special notes in the build email?',
                        $class: 'hudson.model.TextParameterDefinition',
                        defaultValue: ""
                    ],
                ]
            ],
            disableConcurrentBuilds()
        ]
    )

    GITHUB_BASE = "git@github.com:openshift"  // buildlib uses this :eyeroll:
    IS_TEST_MODE = params.TEST
    buildlib.initialize(IS_TEST_MODE)

    BUILD_VERSION_MAJOR = params.BUILD_VERSION.tokenize('.')[0].toInteger() // Store the "X" in X.Y
    BUILD_VERSION_MINOR = params.BUILD_VERSION.tokenize('.')[1].toInteger() // Store the "Y" in X.Y
    SIGN_RPMS = false  // expose param for this if we get to sign RPMs
    ODCS_MODE = false  // expose param for this if we ever get serious about ODCS again
    ODCS_FLAG = ""
    ODCS_OPT = ""
    if (ODCS_MODE) {
        ODCS_FLAG = "--odcs-mode"
        ODCS_OPT = "--odcs unsigned"
    }

    BUILD_EXCLUSIONS = commonlib.cleanCommaList(params.BUILD_EXCLUSIONS)
    BUILD_FAILURES = null

    // Will be used to track which openshift pkg build was tagged before we ran.
    PREV_BUILD = null

    aosCdJobsCommitSha = sh(
        returnStdout: true,
        script: "git rev-parse HEAD",
    ).trim()

    try {
        // Clean up old images so that we don't run out of device mapper space
        sh "docker rmi --force \$(docker images  | grep v${params.BUILD_VERSION} | awk '{print \$3}')"
    } catch (cce) {
        echo "Error cleaning up old images: ${cce}"
    }

    puddleConfBase = "https://raw.githubusercontent.com/openshift/aos-cd-jobs/${aosCdJobsCommitSha}/build-scripts/puddle-conf"
    puddleConf = "${puddleConfBase}/atomic_openshift-${params.BUILD_VERSION}.conf"
    puddleSignKeys = SIGN_RPMS ? "b906ba72" : null

    echo "Initializing build: #${currentBuild.number} - ${params.BUILD_VERSION}.??"

    // doozer_working must be in WORKSPACE in order to have artifacts archived
    DOOZER_WORKING = "${env.WORKSPACE}/doozer_working"
    //Clear out previous work
    sh "rm -rf ${DOOZER_WORKING}"
    sh "mkdir -p ${DOOZER_WORKING}"

    try {
        sshagent(["openshift-bot"]) {
            // To work on real repos, buildlib operations must run with the permissions of openshift-bot

            PREV_BUILD = sh(
                returnStdout: true,
                script: "brew latest-build --quiet rhaos-${params.BUILD_VERSION}-rhel-7-candidate openshift | awk '{print \$1}'"
            ).trim()

            stage("ose repo") {
                // defines:
                //   OPENSHIFT_DIR // by calling initialize_openshift_dir()
                ///  OSE_DIR
                //   GITHUB_URLS["ose"]
                //   GITHUB_BASE_PATHS["ose"]
                buildlib.initialize_ose()
            }

            stage("analyze") {

                dir(OSE_DIR) {
                    // inputs:
                    //  BUILD_VERSION

                    // defines
                    //  OSE_SOURCE_BRANCH
                    //  UPSTREAM_SOURCE_BRANCH
                    //  NEW_VERSION
                    //  NEW_RELEASE
                    //  NEW_DOCKERFILE_RELEASE
                    //
                    //  sets:
                    //    currentBuild.displayName

                    // If the target version resides in ose#master
                    spec = buildlib.read_spec_info("origin.spec")
                    IS_SOURCE_IN_MASTER = (params.BUILD_VERSION == spec.major_minor)

                    if (IS_SOURCE_IN_MASTER) {
                        OSE_SOURCE_BRANCH = "master"
                        UPSTREAM_SOURCE_BRANCH = "upstream/master"
                    } else {
                        OSE_SOURCE_BRANCH = "enterprise-${params.BUILD_VERSION}"
                        UPSTREAM_SOURCE_BRANCH = "upstream/release-${params.BUILD_VERSION}"
                        // Create the non-master source branch and have it track the origin ose repo
                        sh "git checkout -b ${OSE_SOURCE_BRANCH} origin/${OSE_SOURCE_BRANCH}"
                        spec = buildlib.read_spec_info("origin.spec")
                    }

                    echo "Building from ose branch: ${OSE_SOURCE_BRANCH}"

                    rel_fields = spec.release.tokenize(".")

                    if (! spec.version.startsWith("${params.BUILD_VERSION}.")) {
                        // Looks like pipeline thinks we are building something we aren't. Abort.
                        error("Expected version consistent with ${params.BUILD_VERSION}.* but found: ${spec.version}")
                    }


                    NEW_VERSION = params.NEW_VERSION ?: spec.version
                    NEW_RELEASE = new Date().format("yyyy.MM.dd.HH.mm")
                    NEW_DOCKERFILE_RELEASE = NEW_RELEASE

                    rpmOnlyTag = ""
                    if (!params.BUILD_CONTAINER_IMAGES) {
                        rpmOnlyTag = " (RPM ONLY)"
                    }
                    currentBuild.displayName = "#${currentBuild.number} - ${NEW_VERSION}-${NEW_RELEASE} ${rpmOnlyTag}"
                }
            }

            stage("merge origin") {
                // note, this will go away once merge is handled in its own job
                dir(OSE_DIR) {
                    // Enable fake merge driver used in our .gitattributes
                    sh "git config merge.ours.driver true"
                    // Use fake merge driver on specific packages
                    sh "echo 'pkg/assets/bindata.go merge=ours' >> .gitattributes"
                    sh "echo 'pkg/assets/java/bindata.go merge=ours' >> .gitattributes"

                    // Merge upstream origin code into the ose branch
                    sh "git merge -m 'Merge remote-tracking branch ${UPSTREAM_SOURCE_BRANCH}' ${UPSTREAM_SOURCE_BRANCH}"
                    if (!IS_TEST_MODE) {
                        sh "git push"
                    }

                }
            }

            stage("ose tag") {
                dir(OSE_DIR) {
                    // we no longer want to push tito's changes (and tags) to ose.
                    // but push a tag for tito to generate the next changelog against and to match historical practice.
                    def tag = "v${NEW_VERSION}-${NEW_RELEASE}"

                    sh "git tag -am '' ${tag}"
                    if (!IS_TEST_MODE) {
                        sh "git push origin ${tag}"
                    }
                    // but tito needs to believe it owns the new tag so make way for that
                    sh "git tag -d ${tag}"

                    // Set the new version/release value in the file and tell tito to keep the version & release in the spec.
                    // Cannot tito tag --use-release because it does not maintain variables like %{?dist}.
                    buildlib.set_rpm_spec_version("origin.spec", NEW_VERSION)
                    buildlib.set_rpm_spec_release_prefix("origin.spec", NEW_RELEASE)

                    // tito tag commits above changes along with its own.
                    sh "tito tag --no-auto-changelog --keep-version --debug"
                }
            }

            stage("ose rpm build") {

                dir(OSE_DIR) {
                    oseTaskId = sh(
                        returnStdout: true,
                        script: "tito release --debug --yes --test aos-${params.BUILD_VERSION} | grep 'Created task:' | awk '{print \$3}'"
                    )
                    OSE_BREW_URL = "https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=${oseTaskId}"
                    echo "ose rpm brew task: ${OSE_BREW_URL}"
                }

                // Watch the task to make sure it succeeds, or retry if it fails.
                buildlib.watch_brew_task_and_retry("openshift RPM", oseTaskId, OSE_BREW_URL)
            }

            stage("doozer build rpms") {
                buildlib.doozer """
--working-dir ${DOOZER_WORKING} --group 'openshift-${params.BUILD_VERSION}'
--source ose ${OSE_DIR}
rpms:build --version v${NEW_VERSION}
--release ${NEW_RELEASE}
"""
            }

            stage("signing rpms") {
                if (SIGN_RPMS) {
                    sh "${env.WORKSPACE}/build-scripts/sign_rpms.sh rhaos-${params.BUILD_VERSION}-rhel-7-candidate openshifthosted"
                } else {
                    echo "RPM signing has been skipped..."
                }
            }

            stage("puddle: ose 'building'") {
                OCP_PUDDLE = buildlib.build_puddle(
                    puddleConf,    // The puddle configuration file to use
                    puddleSignKeys, // openshifthosted key
                    "-b",   // do not fail if we are missing dependencies
                    "-d",   // print debug information
                    "-n",   // do not send an email for this puddle
                    "-s",   // do not create a "latest" link since this puddle is for building images
                    "--label=building"   // create a symlink named "building" for the puddle
                )
            }

            stage("update dist-git") {
                buildlib.doozer """
--working-dir ${DOOZER_WORKING} --group 'openshift-${params.BUILD_VERSION}'
--source ose ${OSE_DIR}
${ODCS_FLAG}
images:rebase --version v${NEW_VERSION}
--release ${NEW_DOCKERFILE_RELEASE}
--message 'Updating Dockerfile version and release v${NEW_VERSION}-${NEW_DOCKERFILE_RELEASE}' --push
"""
                buildlib.notify_dockerfile_reconciliations(DOOZER_WORKING, ["ose": OSE_SOURCE_BRANCH])
            }

            stage("build images") {
                if (params.BUILD_CONTAINER_IMAGES) {
                    try {
                        exclude = ""
                        if (BUILD_EXCLUSIONS != "") {
                            exclude = "-x ${BUILD_EXCLUSIONS} --ignore-missing-base"
                        }
                        buildlib.doozer """
--working-dir ${DOOZER_WORKING} --group openshift-${params.BUILD_VERSION}
${ODCS_FLAG}
${exclude}
images:build
--push-to-defaults --repo-type unsigned ${ODCS_OPT}
"""
                    }
                    catch (err) {
                        record_log = buildlib.parse_record_log(DOOZER_WORKING)
                        def failed_map = buildlib.get_failed_builds(record_log, true)
                        if (!failed_map) { throw err }  // failed so badly we don't know what failed; assume all

                        BUILD_FAILURES = failed_map.keySet().join(",")  // will make email show PARTIAL
                        currentBuild.result = "UNSTABLE"
                        currentBuild.description = "Failed images: ${BUILD_FAILURES}"

                        def r = buildlib.determine_build_failure_ratio(record_log)
                        if (r.total > 10 && r.ratio > 0.25 || r.total > 1 && r.failed == r.total) {
                            echo "${r.failed} of ${r.total} image builds failed; probably not the owners' fault, will not spam"
                        } else {
                            buildlib.mail_build_failure_owners(failed_map, "aos-team-art@redhat.com", params.MAIL_LIST_FAILURE)
                        }
                    }
                }
            }

            stage("mirror RPMs") {

                NEW_FULL_VERSION = "${NEW_VERSION}-${NEW_RELEASE}"

                SYMLINK_NAME = "latest"
                if (!params.BUILD_CONTAINER_IMAGES) {
                    SYMLINK_NAME = "no-image-latest"
                }

                // Push the building puddle out to the correct directory on the mirrors (e.g. online-int, online-stg, or enterprise-X.Y)
                buildlib.invoke_on_rcm_guest("push-to-mirrors.sh", SYMLINK_NAME, NEW_FULL_VERSION, BUILD_MODE)

                // push-to-mirrors.sh sets up a different puddle name on rcm-guest and the mirrors
                OCP_PUDDLE = "v${NEW_FULL_VERSION}_${OCP_PUDDLE}"
                final mirror_url = get_mirror_url(BUILD_MODE, params.BUILD_VERSION)

                buildlib.invoke_on_rcm_guest("publish-oc-binary.sh", params.BUILD_VERSION, NEW_FULL_VERSION, "openshift")

                echo "Finished building OCP ${NEW_FULL_VERSION}"
                PREV_BUILD = null  // We are done. Don't untag even if there is an error sending the email.
                mail_success(NEW_FULL_VERSION, mirror_url, record_log, commonlib)

            }

            stage('sync images') {
                buildlib.sync_images(
                    BUILD_VERSION_MAJOR,
                    BUILD_VERSION_MINOR,
                    "aos-team-art@redhat.com",
                    currentBuild.number
                )
            }
        }
    } catch (err) {

        ATTN = ""
        try {
            NEW_BUILD = sh(returnStdout: true, script: "brew latest-build --quiet rhaos-${params.BUILD_VERSION}-rhel-7-candidate openshift | awk '{print \$1}'").trim()
            if (PREV_BUILD != null && PREV_BUILD != NEW_BUILD) {
                // Untag anything tagged by this build if an error occured at any point
                sh "brew --user=ocp-build untag-build rhaos-${params.BUILD_VERSION}-rhel-7-candidate ${NEW_BUILD}"
            }
        } catch (err2) {
            ATTN = " - UNABLE TO UNTAG!"
        }

        commonlib.email(
            to: "${params.MAIL_LIST_FAILURE}",
            from: "aos-cicd@redhat.com",
            subject: "Error building OSE: ${params.BUILD_VERSION}${ATTN}",
            body: """Encountered an error while running OCP pipeline: ${err}

Jenkins job: ${env.BUILD_URL}
        """);
        currentBuild.description = "Error while running OCP pipeline:\n${err}"
        currentBuild.result = "FAILURE"
        throw err
    } finally {
        commonlib.safeArchiveArtifacts([
            "doozer_working/*.log",
            "doozer_working/brew-logs/**",
            "doozer_working/*.yaml",
            "doozer_working/*.yml",
        ])
    }
}
