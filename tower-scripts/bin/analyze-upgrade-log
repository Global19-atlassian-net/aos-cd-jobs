#!/usr/bin/python
#
# Analyzes an upgrade log and produces a summary of high-level
# operations, Ansible plays, and input requests; with the line
# numbers from the upgrade log for further details.
#

import argparse
import datetime
import dateutil.parser
import re
import sys

def common_prefix(strings):
    """
    Find the longest string that is a prefix of all the strings.
    """
    if not strings:
        return ''
    prefix = strings[0]
    for s in strings:
        if len(s) < len(prefix):
            prefix = prefix[:len(s)]
        if not prefix:
            return ''
        for i in range(len(prefix)):
            if prefix[i] != s[i]:
                prefix = prefix[:i]
                break
    return prefix


class Line(object):

    MIN_DURATION_SECONDS = 10

    def __init__(self, lineno, message):
        self.lineno = lineno
        self.message = message

    def write_lineno(self, stream):
        stream.write('{0: >6}'.format(self.lineno))
        stream.write(' : ')

    def write_message(self, stream):
        stream.write(self.message)

    def write(self, stream):
        self.write_lineno(stream)
        self.write_message(stream)
        stream.write('\n')


class PlayLine(Line):

    def __init__(self, lineno, message):
        super(PlayLine, self).__init__(lineno, message)
        self.timestamp = None
        self.duration = datetime.timedelta()
        self.hosts = set()

        # None  = unknown
        # True  = all hosts in all tasks skipped
        # False = at least one task did something
        self.skipped = None

    def write_message(self, stream):
        stream.write('  PLAY [{0}]'.format(self.message))
        self.hosts.discard('localhost')
        n_hosts = len(self.hosts)
        if n_hosts == 1:
            stream.write(' [{0}]'.format(self.hosts.pop()))
        elif n_hosts > 1:
            prefix = common_prefix(list(self.hosts))
            if prefix:
                stream.write(' [{0}* x {1}]'.format(prefix, n_hosts))
            else:
                stream.write(' [{0} hosts]'.format(n_hosts))
        if self.timestamp:
            stream.write(self.timestamp.strftime(' (%H:%M:%S %Z)'))
        if self.skipped:
            stream.write(' skipped')
        elif self.duration.total_seconds() >= self.MIN_DURATION_SECONDS:
            stream.write(' took {0}s'.format(self.duration))


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('infile', nargs='?',
                        type=argparse.FileType('r'),
                        default=sys.stdin)
    args = parser.parse_args(sys.argv[1:])

    linebuffer = []
    lineno = 0
    task_name = ''
    saw_task_start = False
    saw_input_requested = False

    # Compile regexp patterns
    re_operation   = re.compile('Running operation: [a-z-]+')
    re_play        = re.compile('PLAY \[(.*)\]')
    re_task        = re.compile('TASK \[(.*)\]')
    re_timestamp   = re.compile('^(.*) \((\d+)\:(\d+)\:(\d+)\.(\d+)\)')
    re_host_result = re.compile('^(ok|changed|skipping): \[(.*?)( .*?)?\]')

    for line in args.infile:
        line = line.rstrip()
        lineno += 1

        if line.startswith('Input requested'):
            linebuffer.append(Line(lineno, line))
            saw_input_requested = True

        elif saw_input_requested:
            linebuffer[-1].message += ' - ' + line
            saw_input_requested = False

        elif saw_task_start:
            play = linebuffer[-1]

            # 1st line after TASK is timestamp
            result = re_timestamp.match(line)
            if result:
                if not play.timestamp:
                    timestamp = dateutil.parser.parse(result.group(1))
                    play.timestamp = timestamp
                duration = datetime.timedelta(
                    hours=int(result.group(2)),
                    minutes=int(result.group(3)),
                    seconds=int(result.group(4)))
                play.duration += duration

            # Subsequent lines are host results
            result = re_host_result.match(line)
            if result:
                host = result.group(2)
                play.hosts.add(host)
                if task_name != 'Gathering Facts':
                    skipped = (result.group(1) == 'skipping')
                    if play.skipped is None:
                        play.skipped = skipped
                    else:
                        play.skipped &= skipped

            # TASK data ends with blank line
            if play.hosts and not line:
                saw_task_start = False

        else:
            result = re_operation.match(line)
            if result:
                linebuffer.append(Line(lineno, result.group()))
                continue

            result = re_play.match(line)
            if result:
                linebuffer.append(PlayLine(lineno, result.group(1)))
                continue

            result = re_task.match(line)
            if result:
                task_name = result.group(1)
                saw_task_start = True
                continue

    while linebuffer:
        linebuffer.pop(0).write(sys.stdout)

if __name__ == '__main__':
    main()
